# Problem 7

> Refs & people discussed with
>
> https://ithelp.ithome.com.tw/articles/10221041
> b09902011 b09902100

## (1)

$16$

## (2)

```pseudocode
function DP(f, N)
	max_ending = array(N)
	max_p = array(N)
	max_ending[2] = f[2]
	max_st[2] = 2
	max_sol = 2
	for i from 3 to N
		max_ending[i] = f[i]
		max_p[i] = i
		if (max_ending[i-1] + f[i] > max_ending[i])
			max_ending[i] = max_ending[i-1] + f[i]
			max_p[i] = max_p[i-1]
		if (max_ending[i] > max_ending[sol])
			sol = i
	return max_ending[sol], max_p[sol], sol

function solve(f, N)
	f_neg = array(N)
	sum_f = 0
	for i from 1 to N
		sum_f += f[i]
		f_neg = -f[i]
	max_sum, max_st, max_ed = DP(f, N)
	min_sum_neg, min_st, min_ed = DP(f_neg, N)
	if (max_sum >= sum_f + min_sum_neg)
		st, ed = max_st, max_ed
	else
		st, ed = min_ed+1, min_st-1
		if (st > N)
			st -= N
	return st, ed
```

The solution should be one of these two cases:

- If the solution doesn't include `f[1]`, the problem becomes finding maximum subarray of `f[2:N]`.
- If the solution does include `f[1]`, the rest of array should be the minimum subarray of `f[2:N]`, and the problem becomes finding minimum subarray of `f[2:N]`.

For finding maximum subarray:

1. Use an array `max_ending`, where `max_ending[i]` is the maximum sum of subarray ending with `f[i]`.
   And an array `max_p` to indicate the start of this subarray.
2. Build `max_ending` bottom with this recurrence relation `max_ending[i] = max(f[i], max_ending[i-1]+f[i])`.
3. While building `max_ending`, also use `max_sol` to store the index of maximum value in `max_ending`.
4. After the array is built, `max_sol` is the end of maximum subarray. Use `max_p` to get the start of maximum subarray.

Finding minimum subarray is essentially the same thing, we just use an array `f_neg` where each element is added a negative sign. Then find the maximum subarray of `f_neg`. Finally, we compare the answer of these two cases and choose the larger one.

## (3)

